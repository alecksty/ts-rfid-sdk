/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>

/* Header for class com_tanso_rfidlib_port_usb_NativeUsb */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <linux/hid.h>
#include <linux/hiddev.h>

/**
 * 类型定义
 */
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long u64;

typedef signed char i8;
typedef signed short i16;
typedef signed int i32;
typedef signed long i64;

/**
 * 声明
 * @param fd
 * @param report_type
 */
static void show_one_report(int fd, unsigned report_type);

static void show_all_report(int fd);

static int read_event(int fd);

/**
 * 主函 * @return
 */
int main2() {
    int fd = -1;
    int version;
    char dev_name[64] = "/dev/usb/hiddev0";
    char name[100];
    struct hiddev_devinfo dinfo;

    //======================
    // Open Driver
    //======================
    fd = open(dev_name, O_RDWR);
    if (fd == -1) {
        fprintf(stderr, "open %s failure!\n", dev_name);
        return -1;
    }

    printf("%s information:\n", dev_name);

    //======================
    // Get Version
    //======================
    if (ioctl(fd, HIDIOCGVERSION, &version) < 0) {
        perror("HIDIOCGVERSION");
    } else {
        // Show Version
        printf("HIDIOCGVERSION: %d.%d\n", (version >> 16) & 0xFFFF, version & 0xFFFF);

        if (version != HID_VERSION) {
            printf("WARNING: version does not match compile-time version\n");
        }
    }

    //======================
    // Get Device Info
    //======================
    if (ioctl(fd, HIDIOCGDEVINFO, &dinfo) < 0) {
        perror("HIDIOCGDEVINFO");
    } else {
        printf("HIDIOCGDEVINFO : bustype=%d,busnum=%d,devnum=%d,ifnum=%d\n"
               "\tvendor=0x%04hx,product=0x%04hx,version=0x%04hx\n"
               "\tnum_applications=%d\n", dinfo.bustype, dinfo.busnum, dinfo.devnum, dinfo.ifnum, dinfo.vendor,
               dinfo.product, dinfo.version, dinfo.num_applications);
    }

    //======================
    // Get Name
    //======================
    if (ioctl(fd, HIDIOCGNAME(99), name) < 0) {
        perror("HIDIOCGNAME");
    } else {
        name[99] = 0;
        printf("HIDIOCGNAME : %s\n", name);
    }

    //
    //show_one_report(fd, HID_REPORT_TYPE_INPUT);
    //
    //show_one_report(fd, HID_REPORT_TYPE_OUTPUT);
    //
    show_all_report(fd);
    //  等待读取
    read_event(fd);
    //
    close(fd);
}

/**
 * 显示单个报文
 * @param fd
 * @param report_type
 */
static void show_one_report(int fd, unsigned report_type) {
    struct hiddev_report_info rinfo;
    struct hiddev_field_info finfo;
    struct hiddev_usage_ref uref;
    int i, j, ret;

    //	Get First Report
    rinfo.report_type = report_type;
    rinfo.report_id = HID_REPORT_ID_FIRST;

    // Get Report Info
    ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);

    while (ret >= 0) {
        printf("HIDIOCGREPORTINFO : report_id=0x%X (%u fields)\n", rinfo.report_id, rinfo.num_fields);

        for (i = 0; i < rinfo.num_fields; i++) {
            finfo.report_type = rinfo.report_type;
            finfo.report_id = rinfo.report_id;
            finfo.field_index = i;

            ioctl(fd, HIDIOCGFIELDINFO, &finfo);

            printf("HIDIOCGFIELDINFO: field_index=%u maxusage=%u flags=0x%X\n"
                   "\tphysical=0x%X logical=0x%X application=0x%X\n"
                   "\tlogical_minimum=%d,maximum=%d physical_minimum=%d,maximum=%d\n", finfo.field_index,
                   finfo.maxusage, finfo.flags, finfo.physical, finfo.logical, finfo.application, finfo.logical_minimum,
                   finfo.logical_maximum, finfo.physical_minimum, finfo.physical_maximum);

            for (j = 0; j < finfo.maxusage; j++) {
                uref.report_type = finfo.report_type;
                uref.report_id = finfo.report_id;
                uref.field_index = i;
                uref.usage_index = j;

                ioctl(fd, HIDIOCGUCODE, &uref);
                ioctl(fd, HIDIOCGUSAGE, &uref);

                printf(" >> usage_index=%u,usage_code=0x%X (),value=%d\n", uref.usage_index, uref.usage_code,
                       uref.value);
            }
        }
        printf("\n");

        //	Get Next Report
        rinfo.report_id |= HID_REPORT_ID_NEXT;
        ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
    }
}

/**
 * 显示全部报文
 * @param fd
 */
void show_all_report(int fd) {
    struct hiddev_report_info rinfo;
    struct hiddev_field_info finfo;
    struct hiddev_usage_ref uref;

    int rtype, i, j;
    const char *rtype_str = NULL;

    for (rtype = HID_REPORT_TYPE_MIN; rtype <= HID_REPORT_TYPE_MAX; rtype++) {
        switch (rtype) {
            case HID_REPORT_TYPE_INPUT:
                rtype_str = "Input";
                break;
            case HID_REPORT_TYPE_OUTPUT:
                rtype_str = "Output";
                break;
            case HID_REPORT_TYPE_FEATURE:
                rtype_str = "Feature";
                break;
            default:
                rtype_str = "Unknown";
                break;
        }
        fprintf(stdout, "Reports of type %s (%d):\n", rtype_str, rtype);

        rinfo.report_type = rtype;
        rinfo.report_id = HID_REPORT_ID_FIRST;

        //	Get Report
        while (ioctl(fd, HIDIOCGREPORTINFO, &rinfo) >= 0) {

            fprintf(stdout, " Report id: %d (%d fields)\n", rinfo.report_id, rinfo.num_fields);

            //  遍历项目
            for (i = 0; i < rinfo.num_fields; i++) {
                memset(&finfo, 0, sizeof(finfo));
                finfo.report_type = rinfo.report_type;
                finfo.report_id = rinfo.report_id;
                finfo.field_index = i;
                ioctl(fd, HIDIOCGFIELDINFO, &finfo);
                fprintf(stdout, " Field: %d: app: %04x phys %04x "
                                "flags %x (%d usages) unit %x exp %d\n", i, finfo.application, finfo.physical,
                        finfo.flags, finfo.maxusage, finfo.unit, finfo.unit_exponent);

                memset(&uref, 0, sizeof(uref));

                for (j = 0; j < finfo.maxusage; j++) {
                    uref.report_type = finfo.report_type;
                    uref.report_id = finfo.report_id;
                    uref.field_index = i;
                    uref.usage_index = j;

                    ioctl(fd, HIDIOCGUCODE, &uref);
                    ioctl(fd, HIDIOCGUSAGE, &uref);

                    fprintf(stdout, " Usage: %04x val %d\n", uref.usage_code, uref.value);
                }
            }
            rinfo.report_id |= HID_REPORT_ID_NEXT;
        }
    }

    fprintf(stdout, "Waiting for events ... (interrupt to exit)\n");
}

#define _PRIVATE static
#define HID_REPORT_SIZE     64
#define HID_REPORT_HEAD     0xAB
#define PRINTF              printf
#define HID_DATA_MAX        64

//=======================================================================
//	函数:	make_checksum
//	参数:
//	返回:
//	说明:	生成校验码
//=======================================================================
_PRIVATE u16 make_checksum(const u8 array[], u16 len) {
    u16 i;
    u16 d = 0;
    for (i = 0; i < len; i++) {
        d += array[i];
    }
    return d;
}

//=======================================================================
//	函数:	from_package
//	参数:
//	返回:
//	说明: 解析包
//=======================================================================
_PRIVATE u16 from_package(const u8 pack[], u16 len, u8 array[]) {
    register u16 i;
    register u16 crc;
    register u16 pkCrc;
    register u8 pkHead;
    register u8 pkLen;

    //	包长
    if (len != HID_REPORT_SIZE) {
        PRINTF("数据包长度不对!(%d)\n", len);
        return 0;
    }

    //	数据头
    pkHead = pack[0];
    if ((pkHead & 0xff) != HID_REPORT_HEAD) {
        PRINTF("数据头不对!(%02x!=%02x)\n", 0xff & pkHead, HID_REPORT_HEAD);
        return 0;
    }

    //	长度
    pkLen = pack[1];
    if (pkLen > (u8) HID_DATA_MAX) {
        PRINTF("数据长度不对!(%d)\n", pkLen);
        return 0;
    }

    //	校验码
    crc = make_checksum(pack, pkLen + 2);
    pkCrc = (pack[pkLen + 2] << 0) | (pack[pkLen + 3] << 8);

    //	验证
    if ((crc & 0xFFFF) != (pkCrc & 0xFFFF)) {
        PRINTF("校验码不对(%04x!=%04x)\n", crc & 0xFFFF, pkCrc & 0xFFFF);
        return 0;
    }

    //	搬数据
    for (i = 0; i < pkLen; i++) {
        array[i] = pack[2 + i];
    }

    return pkLen;
}

//=======================================================================
//	函数:	to_package
//	参数:
//	返回:
//	说明:	生产包
//=======================================================================
_PRIVATE u16 to_package(const u8 data[], u16 len, u8 pack[]) {
    register u16 i = 0;
    register u16 crc = 0;
    register u16 pakLen = 0;

    if (data == NULL) {
        PRINTF("数据对象为空!\n");
        return 0;
    }

    if (pack == NULL) {
        PRINTF("数据包为空!\n");
        return 0;
    }

    if (len > HID_DATA_MAX) {
        PRINTF("数据对象出超!\n");
        return 0;
    }

    pakLen = len;
    //  数据头
    pack[0] = HID_REPORT_HEAD;
    //  长度
    pack[1] = pakLen;
    //  数据
    for (i = 0; i < pakLen; i++) {
        pack[2 + i] = data[i];
    }
    //  校验码
    crc = make_checksum(pack, (pakLen + 2));
    //  校验码低位
    pack[2 + pakLen] = ((crc >> 0) & 0xFF);
    //  校验码高位
    pack[3 + pakLen] = ((crc >> 8) & 0xFF);

    return (3 + pakLen);
}

/**
 * 获取设备名称
 * @param fd
 */
void report_get_name(int fd) {
    const int NAME_MAX_LEN = 100;
    static char name[NAME_MAX_LEN];
    //======================
    // Get Name
    //======================
    if (ioctl(fd, HIDIOCGNAME(NAME_MAX_LEN - 1), name) < 0) {
        perror("HIDIOCGNAME");
    } else {
        name[NAME_MAX_LEN - 1] = 0;
        printf("hid device name : %s\n", name);
    }
}

/**
 *
 * @param fd
 */
const char *report_get_string(int fd, int index) {
    static struct hiddev_string_descriptor hsd;

    memset(&hsd, 0, sizeof(hsd));

    hsd.index = index;

    if (ioctl(fd, HIDIOCGSTRING, &hsd) < 0) {
        perror("HIDIOCGSTRING");
        return NULL;
    } else {
        //printf("hid device name : %s\n", hsd.value);
    }
    return (const char *) hsd.value;
}

/**
 * 输出报文
 * @param fd
 * @param array
 * @param len
 * @return
 */
int report_input(int fd, u8 array[], int len) {
    int ret = 0;
    struct hiddev_report_info rinfo;
    struct hiddev_field_info finfo;
    struct hiddev_usage_ref uref;
    // struct hiddev_usage_ref_multi urefs;

    printf("-----------------------------------\r\n");
    printf("HID_REPORT_TYPE_INPUT\r\n");
    printf("-----------------------------------\r\n");

    // Read Report Info ?
    rinfo.report_type = HID_REPORT_TYPE_INPUT;
    //rinfo.report_id     = HID_REPORT_ID_FIRST;
    rinfo.report_id = 0;
    ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
//    ret                 = ioctl(fd, HIDIOCGREPORT, &rinfo);

    printf("report.num_fields : %d\n", rinfo.num_fields);

    //  遍历字段
    for (int i = 0; i < rinfo.num_fields; i++) {
        finfo.report_type = rinfo.report_type;
        finfo.report_id = rinfo.report_id;
        finfo.field_index = i;

        ioctl(fd, HIDIOCGFIELDINFO, &finfo);

        printf("field[%d].max_usage:%d\n", i, finfo.maxusage);

        //  类型
        uref.report_type = finfo.report_type;
        uref.report_id = finfo.report_id;
        uref.field_index = i;
        uref.usage_code = 3;

        //  遍历用法
        for (int j = 0; j < finfo.maxusage; j++) {
            //  用法
            uref.usage_index = j;
            //
            //  读取 UsegeCode
            //ret = ioctl(fd, HIDIOCGUCODE, &uref);

            //printf("usage report_type:%d,report_id:%d,field_index:%d,usage_index:%d,usage_code:%x,value:%x\n",
            //       uref.report_type, uref.report_id, uref.field_index, uref.usage_index, uref.usage_code, uref.value);

            //if(ret < 0){
            //    printf("HIDIOC_GET_UCODE error:%d\n",ret);
            //}
            ret = ioctl(fd, HIDIOCGUSAGE, &uref);
            if (ret < 0) {
                printf("HIDIOC_GET_USAGE error:%d\n", ret);
            }

            //printf("usage report_type:%d,report_id:%d,field_index:%d,usage_index:%d,usage_code:%x,value:%x\n",
            //       uref.report_type, uref.report_id, uref.field_index, uref.usage_index, uref.usage_code, uref.value);
            /**
            printf("usage report_type:%d,report_id:%d,field_index:%d,usage_index:%d,usage_code:%d,value:%x\n",
                   uref.report_type,
                   uref.report_id,
                   uref.field_index,
                   uref.usage_index,
                   uref.usage_code,
                   uref.value);
            */

            //  收集数据
            array[j] = uref.value;
            //
            printf("%02x,", uref.value);
            if (j % 16 == 15) {
                printf("\r\n");
            }
        }
    }

    printf(" --- OUTPUT Done! ---\n");

    return finfo.maxusage;
}

/**
 * 输出报文
 * @param fd
 * @param array
 * @param len
 * @return
 */
int report_output(int fd, u8 array[], int len) {
    int ret = 0;
    struct hiddev_report_info rinfo;
    struct hiddev_field_info finfo;
    struct hiddev_usage_ref uref;
    struct hiddev_usage_ref_multi urefs;

    printf("-----------------------------------\r\n");
    printf("HID_REPORT_TYPE_OUTPUT\r\n");
    printf("-----------------------------------\r\n");

    //  输出报文
    rinfo.report_type = HID_REPORT_TYPE_OUTPUT;
    //rinfo.report_id   = HID_REPORT_ID_FIRST;
    rinfo.report_id = 0;
    ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);

    printf("report.num_fields : %d\n", rinfo.num_fields);

    for (int i = 0; i < rinfo.num_fields; i++) {
        finfo.report_type = rinfo.report_type;
        finfo.report_id = rinfo.report_id;
        finfo.field_index = i;

        //  读取 Field Info
        ioctl(fd, HIDIOCGFIELDINFO, &finfo);

        printf("field[%d].max_usage:%d\n", i, finfo.maxusage);

        urefs.uref.report_type = finfo.report_type;
        urefs.uref.report_id = finfo.report_id;
        urefs.uref.field_index = i;
        urefs.uref.usage_index = 0;
        urefs.uref.usage_code = 4; // 设备相关

        urefs.num_values = len;

        for (int j = 0; j < finfo.maxusage; j++) {
            //  用法索引
            //urefs.uref.usage_index = j;
            //  代码索引()
            //urefs.uref.usage_code += 4;
            //  这里怎么用?
            //urefs.uref.value = array[j];
            //  复制数据
            urefs.values[j] = array[j];

            /*
            printf("usage[%d]=%02x,%02x\n",
                   urefs.uref.usage_index,
                   urefs.uref.usage_code,
                   urefs.values[j]);
            */
            printf("%02x,", urefs.values[j]);
            if (j % 16 == 15) {
                printf("\r\n");
            }
        }

        //  发送一批?
        if ((ret = ioctl(fd, HIDIOCSUSAGES, &urefs)) == 0){
            printf("set usage success..\n");
        }else{
            printf("set usage failed...(%d)\n", ret);
        }

        rinfo.report_type = HID_REPORT_TYPE_OUTPUT;
        rinfo.report_id = HID_REPORT_ID_FIRST;

        if ((ret = ioctl(fd, HIDIOCSREPORT, &rinfo)) == 0){
            printf("set report success...\n");
        }else{
            printf("set report failed...(%d)\n", ret);
        }
    }
    return 1;
}

int main(int argc, char **argv) {
    int fd = -1;
    u8 byInput[64];
    u8 byOutput[64];
    //{0xBB,0x00,0x22,0x00,0x00,0x22,0x7E}
    u8 tst[] = {0xBB,0x00,0x22,0x00,0x00,0x22,0x7E};

    if (argc != 2) {
        fprintf(stderr, "usage : %s <hid device>\n", argv[0]);
        return -1;
    }

    //  打开设备
    if ((fd = open(argv[1], O_RDONLY)) < 0) {
        perror("hid-dev open");
        return -1;
    }

    memset(byOutput,0,sizeof(byOutput));
    memset(byInput,0,sizeof(byInput));

    //  Make Package
    to_package(tst,sizeof(tst),byOutput);

    //  get device name！
    report_get_name(fd);

    for (int i = 1; i < 4; i++) {
        printf("string[%d] : (%s)\n", i, report_get_string(fd, i));
    }

    //  Send Output Report
    report_output(fd, byOutput, sizeof(byOutput));
    //  Send Input Report
    report_input(fd, byInput, sizeof(byInput));
    //  Send Output Report
    report_output(fd, byOutput, sizeof(byOutput));
    //  Send Input Report
    report_input(fd, byInput, sizeof(byInput));

    close(fd);

    //exit(0);
    return 0;
}

//======================================================================
//	Read Data?
//======================================================================
/**
 * 读取事件
 * @param fd
 * @return
 */
int read_event(int fd) {
    //
    static u8 ev[64];
    int i, rd;
    long delay = 0;

    printf("Waiting Event ...\r\n");

    while (delay++ < 10000000) {

        rd = read(fd, ev, sizeof(ev));

        if (rd < (int) sizeof(ev[0])) {
            if (rd < 0) {
                perror("\nevtest : error reading!");
            }
            return -1;
        }

        printf("\r\n");
        for (i = 0; i < sizeof(ev); i++) {
            printf("%02x,",ev[i]);
            if(i % 16 == 15){
                printf("\r\n");
            }
        }
    }

    printf("Waiting Done ...\r\n");
    return 0;
}

///===================================================================================================
///
///===================================================================================================

/**
 *  fd for Open
 */
static int fd = 0;
static int isConnect = 0;
static u8 hid_buffer[64];

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Open
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Open(JNIEnv *env, jobject thiz, jstring filename) {
    const char *real_filename = NULL;
    jboolean flag = 0;

    // get string
    real_filename = (env)->GetStringUTFChars(filename, &flag);

    //  文件名
    if (real_filename == 0) {
        fprintf(stdout, "filename is null\n");
        return -1;
    }

    //  打开名媛
    fd = open(real_filename, O_RDWR);

    // Release String
    (env)->ReleaseStringUTFChars(filename, real_filename);

    if (fd < 0) {
        fprintf(stdout, "open error %d\n", fd);
        return fd;
    }

    return 0;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Close
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Close(JNIEnv *env, jobject thiz) {
    if (fd != 0) {
        fprintf(stdout, "close device %d\n", fd);
        close(fd);
        fd = 0;
        return 0;
    }
    return -1;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    GetName
 * Signature: (I)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_GetName(JNIEnv *env, jobject thiz, jint index) {
    const int MAX_DEVICE_NAME = 100;
    static char name[MAX_DEVICE_NAME];

    // Get Name.
    if (ioctl(fd, HIDIOCGNAME(MAX_DEVICE_NAME - 1), name) < 0) {
        perror("HIDIOCGNAME");
    } else {
        name[MAX_DEVICE_NAME - 1] = 0;
        printf("HIDIOCGNAME : %s\n", name);
    }

    //  分配字符
    return (env)->NewStringUTF(name);
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    GetCount
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_GetCount(JNIEnv *env, jobject thiz) {
    return (jint) 1;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    SetSelect
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_SetSelect(JNIEnv *env, jobject thiz, jint sel) {
    return (jint) 0;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    GetSelect
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_GetSelect(JNIEnv *env, jobject thiz) {
    return (jint) 0;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Connect
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Connect(JNIEnv *env, jobject thiz) {
    if (fd) {
        isConnect = 1;
    } else {
        isConnect = 0;
    }
    return (jint) isConnect;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Disconnect
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Disconnect(JNIEnv *env, jobject thiz) {
    if (fd) {
        if (!isConnect) {
            //isConnect = 1;
        } else {
            isConnect = 0;
        }
    } else {
        isConnect = 0;
    }
    return (jint) isConnect;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    isConnected
 * Signature: ()Z
 */
JNIEXPORT jboolean JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_isConnected(JNIEnv *, jobject) {
    return (jboolean) isConnect;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    GetBytes
 * Signature: ()I
 */

JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_GetBytes(JNIEnv *, jobject) {
    if (fd) {
        return (jint) read(fd, hid_buffer, sizeof(hid_buffer));
    }
    return 0;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Scan
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Scan(JNIEnv *env, jobject thiz, jboolean OnOff) {
    if (OnOff) {
        //  扫描打开
    } else {
        //  扫描关闭
    }
    return (jint) 0;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Write
 * Signature: ([BII)I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Write(JNIEnv *env, jobject thiz, jbyteArray data) {
    jbyte *pd;
    jboolean isCopy = 0;
    int len = 64;

    //  获取数据
    pd = (env)->GetByteArrayElements(data, &isCopy);
    //  写入数据
    int ret = write(fd, pd, (env)->GetArrayLength(data));
    //  释放
    (env)->ReleaseByteArrayElements(data, pd, 0);

    return (jint) ret;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Read
 * Signature: ()[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Read(JNIEnv *env, jobject thiz) {
    int ret = 0;
    int isCopy = 0;
    static u8 buffer[256];
    u8 *pd = NULL;

    //  读取
    ret = read(fd, buffer, sizeof(buffer));
    //  创建值
    jbyteArray ba = (env)->NewByteArray(ret);
    //  设置值
    (env)->SetByteArrayRegion(ba, 0, ret, reinterpret_cast<const jbyte *>(pd));

    return ba;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    IoCtrl
 * Signature: (I[B)[B
 */
JNIEXPORT jbyteArray
JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_IoCtrl(JNIEnv *env, jobject thiz, jint param, jbyteArray data) {
    jbyte *pd;
    jboolean isCopy;

    //  获取数据
    pd = (env)->GetByteArrayElements(data, &isCopy);
    //  写入数据
    int ret = ioctl(fd, param, pd);
    //  释放
    (env)->ReleaseByteArrayElements(data, pd, 0);
    //  创建
    jbyteArray ba = (env)->NewByteArray(1);

    return ba;
}
