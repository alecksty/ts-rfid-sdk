/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>

/* Header for class com_tanso_rfidlib_port_usb_NativeUsb */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <linux/hid.h>
#include <linux/hiddev.h>
#include <pthread.h>

/**
 * 宏定义
 */

#define _DEBUG
//#define _DEBUG_INFO

#define _PRIVATE            static
#define HID_REPORT_SIZE     64
#define HID_REPORT_HEAD     0xAB
#define PRINTF              printf
#define HID_DATA_MAX        HID_REPORT_SIZE

/**
 * 类型定义
 */
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long u64;

typedef signed char i8;
typedef signed short i16;
typedef signed int i32;
typedef signed long i64;

/**
 * 互斥锁定
 */
static pthread_mutex_t mt;

#ifdef __cplusplus
extern "C" {
#endif

int read_event(int fd);
int report_read(int fd, u8 array[], int len);
int report_input(int fd, u8 array[], int len);
int report_output(int fd, const u8 array[], int len);

//=======================================================================
//	函数:	make_checksum
//	参数:
//	返回:
//	说明:	生成校验码
//=======================================================================
_PRIVATE u16 make_checksum(const u8 array[], u16 len) {
    u16 i;
    u16 d = 0;
    for (i = 0; i < len; i++) {
        d += array[i];
    }
    return d;
}

//=======================================================================
//	函数: from_package
//	参数:
//	返回:
//	说明: 解析包
//=======================================================================
_PRIVATE u16 from_package(const u8 pack[], u16 len, u8 array[]) {
    u16 i;
    u16 crc;
    u16 pkCrc;
    u8 pkHead;
    u8 pkLen;

    //	包长
    if (len != HID_REPORT_SIZE) {
#ifdef _DEBUG_INFO
        PRINTF("ERROR : len(%d) != HID_REPORT_SIZE(%d)\n", len,HID_REPORT_SIZE);
#endif
        return 0;
    }

    //	数据头
    pkHead = pack[0];
    if ((pkHead & 0xff) != HID_REPORT_HEAD) {
#ifdef _DEBUG_INFO
        PRINTF("ERROR : Report Head Wrong (%02x!=%02x)\n", 0xff & pkHead, HID_REPORT_HEAD);
#endif
        return 0;
    }

    //	长度
    pkLen = pack[1];
    if (pkLen > (u8) HID_DATA_MAX) {
#ifdef _DEBUG_INFO
        PRINTF("ERROR : pkLen (%d > %d)\n", pkLen,HID_DATA_MAX);
#endif
        return 0;
    }

    //	校验码
    crc = make_checksum(pack, pkLen + 2);
    pkCrc = (pack[pkLen + 2] << 0) | (pack[pkLen + 3] << 8);

    //	验证
    if ((crc & 0xFFFF) != (pkCrc & 0xFFFF)) {
#ifdef _DEBUG
        PRINTF("ERROR : CRC Wrong (%04x!=%04x)\n", crc & 0xFFFF, pkCrc & 0xFFFF);
#endif
        return 0;
    }

    //	搬数据
    for (i = 0; i < pkLen; i++) {
        array[i] = pack[2 + i];
    }

    return pkLen;
}

//=======================================================================
//	函数: to_package
//	参数:
//	返回:
//	说明: 生产包
//=======================================================================
_PRIVATE u16 to_package(const u8 data[], u16 len, u8 pack[]) {
    u16 i = 0;
    u16 crc = 0;
    u16 pakLen = 0;

    if (data == nullptr) {
#ifdef _DEBUG
        PRINTF("ERROR : data is (null)!\n");
#endif
        return 0;
    }

    if (pack == nullptr) {
#ifdef _DEBUG
        PRINTF("ERROR : pack is (null)!\n");
#endif
        return 0;
    }

    if (len > HID_DATA_MAX) {
#ifdef _DEBUG
        PRINTF("ERROR : len over size!\n");
#endif
        return 0;
    }

    pakLen = len;
    //  数据头
    pack[0] = HID_REPORT_HEAD;
    //  长度
    pack[1] = pakLen;
    //  数据
    for (i = 0; i < pakLen; i++) {
        pack[2 + i] = data[i];
    }
    //  校验码
    crc = make_checksum(pack, (pakLen + 2));
    //  校验码低位
    pack[2 + pakLen] = ((crc >> 0) & 0xFF);
    //  校验码高位
    pack[3 + pakLen] = ((crc >> 8) & 0xFF);

    return (3 + pakLen);
}

/**
 * 读取消息
 * @param fd
 * @return
 */
int read_event_all(int fd)
{
    struct hiddev_event ev[64];
    int i, rd;
    int count = 0;
    time_t curr_time;
    char name[100];
    u8 byInput[64];
    u8 byOutput[64];
    u8 tst[] = {0xBB, 0x00, 0x22, 0x00, 0x00, 0x22, 0x7E};
    //  Make Package
    to_package(tst, sizeof(tst), byOutput);

    while (1) {
        //  清空
        memset(&ev,0,sizeof(ev));
        //  读取
        rd = read(fd, ev, sizeof(ev));
        if (rd < (int) sizeof(ev[0])) {
            if (rd < 0) {
#ifdef _DEBUG
                //perror("\nev test: error reading");
#endif
            }
            //  输出指令
            report_output(fd, byOutput, sizeof(byOutput));
            continue;
        }

        curr_time   = time(nullptr);
        strftime(name, sizeof(name), "%b %d %T", localtime(&curr_time));

    #ifdef _DEBUG
        fprintf(stdout, "--> (%s)[%d]:\r\n", name,count++);
    #endif

        for (i = 0; i < rd / sizeof(ev[0]); i++) {
            int idx     = ev[i].hid;
    #ifdef _DEBUG
            fprintf(stdout, "%02x,", ev[i].value);
            if(i % 16 == 15) {
                fprintf(stdout, "\r\n");
            }
    #endif
        }

    #ifdef _DEBUG
        fprintf(stdout, "---\r\n");
    #endif
    }
    return 0;
}

/**
 * 读取事件
 * @param fd
 * @return
 */
int read_event(int fd) {
    //
    struct hiddev_event ev[1];
    int i, rd;
    long delay = 0;

    printf("Waiting Event ...\r\n");

    while (delay++ < 10000000) {
        rd = read(fd, ev, sizeof(ev));
        if (rd < (int) sizeof(ev[0])) {
            if (rd < 0) {
                perror("\nev test : error reading!");
            }
            return -1;
        }

        printf("\r\n");
        for (i = 0; i < sizeof(ev); i++) {
            if (ev[i].hid) {
                fprintf(stdout, "Event: hid:%x,val:%02x\n", ev[i].hid, ev[i].value);
            }
        }
    }

    printf("Waiting Done ...\r\n");
    return 0;
}

/**
 * 获取设备名称
 * @param fd
 */
void report_get_name(int fd) {
    const int NAME_MAX_LEN = 100;
    static char name[NAME_MAX_LEN];

    //  Read Device length.
    if (ioctl(fd, HIDIOCGNAME(NAME_MAX_LEN - 1), name) < 0) {
        perror("HID_IOC_GET_NAME");
    } else {
        name[NAME_MAX_LEN - 1] = 0;
#ifdef _DEBUG
        printf("hid device name : %s\n", name);
#endif
    }
}

/**
 * 获取字符串
 * @param fd
 */
const char *report_get_string(int fd, int index) {
    static struct hiddev_string_descriptor hsd;
    //  清空
    memset(&hsd, 0, sizeof(hsd));
    //  序号
    hsd.index = index;
    //  获取字符串
    if (ioctl(fd, HIDIOCGSTRING, &hsd) < 0) {
        perror("HID_IOC_GET_STRING");
        return nullptr;
    }

    return (const char *) hsd.value;
}

/**
 * 读取
 * @param fd : 句柄
 * @param array : 数据
 * @param len : 长度
 * @return
 */
int report_read(int fd, u8 array[], int len) {
    static int ret = 0;
    static struct hiddev_report_info rinfo;
    static struct hiddev_field_info finfo;
    static struct hiddev_usage_ref uref;
    static struct hiddev_usage_ref_multi urefs;

    if (!fd) {
#ifdef _DEBUG
        printf(" fd is (null)\r\n");
#endif
        return 0;
    }

#ifdef _DEBUG_INFO
    printf("-----------------------------------\r\n");
    printf(" HID_REPORT_TYPE_INPUT\r\n");
    printf("-----------------------------------\r\n");
#endif

    // Read Report Info ?
    rinfo.report_type   = HID_REPORT_TYPE_INPUT;
    rinfo.report_id     = 0;
    ret                 = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);

#ifdef _DEBUG
    printf("report.num_fields : %d\n", rinfo.num_fields);
#endif

    //  遍历字段
    for (int i = 0; i < rinfo.num_fields; i++) {
        finfo.report_type = rinfo.report_type;
        finfo.report_id = rinfo.report_id;
        finfo.field_index = i;

        ioctl(fd, HIDIOCGFIELDINFO, &finfo);
#ifdef _DEBUG
        printf("field[%d].max_usage:%d\n", i, finfo.maxusage);
#endif
        //  类型
        urefs.uref.report_type = finfo.report_type;
        urefs.uref.report_id = finfo.report_id;
        urefs.uref.field_index = i;

        urefs.uref.usage_index = 0;
        urefs.uref.usage_code = 3;
        urefs.num_values = len;

        //  批量读取数据
        ret = ioctl(fd, HIDIOCGUSAGES, &urefs);
        if (ret < 0) {
#ifdef _DEBUG
            printf("HID_IOC_GET_USAGE error:%d\r\n", ret);
#endif
            return 0;
        }

        //  遍历用法
        for (int j = 0; j < len; j++) {
            //  收集数据
            array[j] = urefs.values[j];
#ifdef _DEBUG_INFO
            //  调试输出
            printf("%02x,", array[j]);
            if (j % 16 == 15) {
                printf("\r\n");
            }
#endif
        }
    }

#ifdef _DEBUG
    printf(" --- INPUT Done (%d)! ---\n", len);
#endif

    return len;
}

/**
 * 输出报文
 * @param fd
 * @param array
 * @param len
 * @return
 */
int report_input(int fd, u8 array[], int len) {
    static int ret = 0;
    static struct hiddev_report_info rinfo;
    static struct hiddev_field_info finfo;
    static struct hiddev_usage_ref uref;
    static struct hiddev_usage_ref_multi urefs;
    struct hiddev_event ev[64];

    if (!fd) {
        printf(" fd is (null)\r\n");
        return 0;
    }

#ifdef _DEBUG_INFO
    printf("-----------------------------------\r\n");
    printf(" HID_REPORT_TYPE_INPUT\r\n");
    printf("-----------------------------------\r\n");
#endif

    // Read Report Info ?
    rinfo.report_type = HID_REPORT_TYPE_INPUT;
    rinfo.report_id = 0;
    //ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);

    rinfo.num_fields = 1;

#ifdef _DEBUG_INFO
    printf("report.num_fields : %d\n", rinfo.num_fields);
#endif

    //  遍历字段
    for (int i = 0; i < rinfo.num_fields; i++) {

        finfo.report_type = rinfo.report_type;
        finfo.report_id = rinfo.report_id;
        finfo.field_index = i;

        //ioctl(fd, HIDIOCGFIELDINFO, &finfo);

#ifdef _DEBUG_INFO
        printf("field[%d].max_usage:%d\n", i, finfo.maxusage);
#endif
        //  类型
        urefs.uref.report_type = finfo.report_type;
        urefs.uref.report_id = finfo.report_id;
        urefs.uref.field_index = i;

        urefs.uref.usage_index = 0;
        urefs.uref.usage_code = 3;
        urefs.num_values = len;

        //  批量读取数据
        ret = ioctl(fd, HIDIOCGUSAGES, &urefs);
        if (ret < 0) {
#ifdef _DEBUG
            printf("HID_IOC_GET_USAGE error:%d\r\n", ret);
#endif
            return 0;
        }

        //  遍历用法
        for (int j = 0; j < len; j++) {
            //  收集数据
            array[j] = urefs.values[j];
#ifdef _DEBUG_INFO
            //  调试输出
            printf("%02x,", array[j]);
            if (j % 16 == 15) {
                printf("\r\n");
            }
#endif
        }

        //  清掉
        urefs.num_values = 0;
        ret = ioctl(fd, HIDIOCSUSAGES, &urefs);
    }

#ifdef _DEBUG_INFO
    printf(" --- INPUT Done (%d)! ---\n", len);
#endif

    return len;
}

/**
 * 输出报文
 * @param fd
 * @param array
 * @param len
 * @return
 */
int report_output(int fd, const u8 array[], int len) {
    static int ret = 0;
    static struct hiddev_report_info rinfo;
    static struct hiddev_field_info finfo;
    static struct hiddev_usage_ref uref;
    static struct hiddev_usage_ref_multi urefs;

    if (!fd) {
        printf("ERROR : fd is %d\r\n", fd);
        return 0;
    }

#ifdef _DEBUG_INFO
    printf("-----------------------------------\r\n");
    printf("HID_REPORT_TYPE_OUTPUT\r\n");
    printf("-----------------------------------\r\n");
#endif

    //  输出报文
    rinfo.report_type       = HID_REPORT_TYPE_OUTPUT;
    rinfo.report_id         = 0;
    ret                     = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);

#ifdef _DEBUG_INFO
    printf("report.num_fields : %d\n", rinfo.num_fields);
#endif

    for (int i = 0; i < rinfo.num_fields; i++) {
        finfo.report_type   = rinfo.report_type;
        finfo.report_id     = rinfo.report_id;
        finfo.field_index   = i;

        //  读取 Field Info
        ioctl(fd, HIDIOCGFIELDINFO, &finfo);

#ifdef _DEBUG_INFO
        printf("field[%d].max_usage:%d\n", i, finfo.maxusage);
#endif
        urefs.uref.report_type  = finfo.report_type;
        urefs.uref.report_id    = finfo.report_id;
        urefs.uref.field_index  = i;
        urefs.uref.usage_index  = 0;
        urefs.uref.usage_code   = 4; // 设备相关
        urefs.num_values        = len;

        for (int j = 0; j < len; j++) {
            //  复制数据
            urefs.values[j] = array[j];
#ifdef _DEBUG_INFO
            printf("%02x,", urefs.values[j]);
            if (j % 16 == 15) {
                printf("\r\n");
            }
#endif //_DEBUG_INFO
        }

        //  发送一批?
        if ((ret = ioctl(fd, HIDIOCSUSAGES, &urefs)) == 0){
#ifdef _DEBUG_INFO
            printf("set usage success..\n");
#endif
        }else{
            printf("set usage failed...(%d,%d)\n", ret, fd);
        }

        rinfo.report_type       = HID_REPORT_TYPE_OUTPUT;
        rinfo.report_id         = HID_REPORT_ID_FIRST;

        if ((ret = ioctl(fd, HIDIOCSREPORT, &rinfo)) == 0){
#ifdef _DEBUG_INFO
            printf("set report success...\n");
#endif
        }else{
            printf("set report failed...(%d,%d)\n", ret, fd);
        }
    }

#ifdef _DEBUG_INFO
    printf(" --- OUTPUT Done (%d)! ---\n", len);
#endif

    return len;
}

///===================================================================================================
///
///===================================================================================================
int main(int argc, char **argv) {
    int fd = -1;

    u8 byInput[64];
    u8 byOutput[64];

    u8 tst[] = {0xBB, 0x00, 0x22, 0x00, 0x00, 0x22, 0x7E};

    if (argc != 2) {
        fprintf(stderr, "usage : %s <hid device>\n", argv[0]);
        return -1;
    }

    //  打开设备
    if ((fd = open(argv[1], O_RDONLY|O_NONBLOCK)) < 0) {
        perror("hid-dev open");
        return -1;
    }

    memset(byOutput, 0, sizeof(byOutput));
    memset(byInput, 0, sizeof(byInput));

    //  Make Package
    to_package(tst, sizeof(tst), byOutput);

    //  get device name！
    report_get_name(fd);

    for (int i = 1; i < 4; i++) {
        printf("string[%d] : (%s)\n", i, report_get_string(fd, i));
    }

    //  Send Output Report
    report_output(fd, byOutput, sizeof(byOutput));
    //  Send Input Report
    report_input(fd, byInput, sizeof(byInput));

    read_event_all(fd);

    close(fd);

    return 0;
}

///===================================================================================================
///
///===================================================================================================
//  文件句柄
static int hid_fd = 0;

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Open
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Open(JNIEnv *env, jobject thiz, jstring name) {
    const char *pfile = nullptr;
    jboolean flag = 0;

    // get string
    pfile = (env)->GetStringUTFChars(name, &flag);
    //  文件名
    if (!pfile) {
        fprintf(stdout, "ERROR:file name is (null)\n");
        return -1;
    }

    printf("open file (%s)！\n", pfile);

    //  初始化 - 锁定
    pthread_mutex_init(&mt, NULL);

    //  打开设备
    int fd = open(pfile, O_RDWR|O_NONBLOCK);
    //  成功
    if (fd > 0) {
        fprintf(stdout, "open file (%s) success!\n", pfile);
    }
    //  释放
    (env)->ReleaseStringUTFChars(name, pfile);
    //  错误
    if (fd < 0) {
        fprintf(stdout, "ERROR:open error %d\n", fd);
        return fd;
    }
    //  关联
    hid_fd = fd;
    //  成功(返回 >= 0)
    return fd;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Close
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Close(JNIEnv *env, jobject thiz) {

    fprintf(stdout, "close file (%d) success!\n", hid_fd);

    if (hid_fd > 0) {
        //  销毁
        pthread_mutex_destroy(&mt);
        //
        close(hid_fd);
        //
        hid_fd = 0;
        //
        return 1;
    }

    return -1;
}


/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    GetName
 * Signature: (I)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_GetName(JNIEnv *env, jobject thiz, jint index) {

    const int MAX_DEVICE_NAME = 255;
    static char name[MAX_DEVICE_NAME];

    //  clear data
    memset(name, 0, sizeof(name));

    // Get Name.
    if (index == 0) {
        if (ioctl(hid_fd, HIDIOCGNAME(MAX_DEVICE_NAME - 1), name) < 0) {
            perror("HID_IOC_GET_NAME");
        } else {
            name[MAX_DEVICE_NAME - 1] = 0;
#ifdef _DEBUG
            printf("HID_IOC_GET_NAME : %s\n", name);
#endif
        }
    } else {
        strcpy(name, report_get_string(hid_fd, index));
    }
    //  分配字符
    return (env)->NewStringUTF(name);
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    IsOpened
 * Signature: ()Z
 */
JNIEXPORT jboolean JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_IsOpened(JNIEnv *, jobject) {
    if (hid_fd > 0) {
        return JNI_TRUE;
    }
    return JNI_FALSE;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Write
 * Signature: ([B)I
 */
JNIEXPORT jint JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Write(JNIEnv *env, jobject thiz, jbyteArray array) {

#if 1
    jint len    = 0;
    jint size   = 0;
    jint ret    = 0;
    jbyte *pd   = nullptr;
    jbyte *pa   = nullptr;
    jboolean isCopy = JNI_FALSE;
    static u8 buffer[HID_REPORT_SIZE];

    if (hid_fd <= 0) {
        printf("ERROR : (Write) hid_fd is (null)!\r\n");
        return 0;
    }

    //  清空
    memset(buffer, 0, sizeof(buffer));
    //  获取长度
    size = (env)->GetArrayLength(array);
    //
    ret = size;

    if (!size) {
        printf("size is 0\r\n");
        return 0;
    }
#endif

    //  获取数据
    pd = (env)->GetByteArrayElements(array, &isCopy);

    pa = pd;
    //  计算
    do {
        if (size > (HID_REPORT_SIZE - 4)) {
            len = HID_REPORT_SIZE - 4;
        } else {
            len = size;
        }
        //  打包
        to_package((const u8 *) pa, len, buffer);

        //  锁定
        pthread_mutex_lock(&mt);
        //  输出
        report_output(hid_fd, (const u8 *) buffer, HID_REPORT_SIZE);
        //  解锁
        pthread_mutex_unlock(&mt);

        //  移动
        pa += len;
        //  大小
        size -= len;
    } while (size > 0);
    //  释放
    (env)->ReleaseByteArrayElements(array, pd, 0);
    //  成功
    return (jint) ret;

    return 0;
}

/*
 * 读取数据
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    Read
 * Signature: ()[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_Read(JNIEnv *env, jobject thiz) {
    jint ret = 0;
    u8 *pd = nullptr;
    jboolean isCopy = JNI_TRUE;
    static u8 buffer[HID_REPORT_SIZE];
    static u8 data[HID_REPORT_SIZE];

    if (!hid_fd) {
        printf("ERROR : (Read) hid_fd is (null)!\r\n");
        return 0;
    }

    //   清空
    memset(buffer, 0, sizeof(buffer));
    memset(data, 0, sizeof(data));

#if 0
    //  读取
    ret = report_input(hid_fd, buffer, sizeof(buffer));
    //  解码
    ret = from_package(buffer, HID_REPORT_SIZE, data);
    //
    //printf(">>>received data(%d)!\r\n", ret);
#else
    static struct hiddev_event evn[HID_REPORT_SIZE];
    //  清空
    memset(evn, 0, sizeof(evn));
    //  锁定
    pthread_mutex_lock(&mt);
    //  读取
    ret = read(hid_fd, evn, sizeof(evn));
    //  解锁
    pthread_mutex_unlock(&mt);

    if(ret < 1){
        return nullptr;
    }

    //  根据长度
    for (int i = 0; i < ret / sizeof(evn[0]); i++) {
        if (evn[i].hid == 0x8C0003) {
            buffer[i] = evn[i].value & 0xFF;
        } else {
            printf("ERROR : HID[%d] id = %04x\r\n", i, evn[i].hid);
        }
    }

    //  解码
    ret = from_package(buffer, HID_REPORT_SIZE, data);
#ifdef _DEBUG_INFO
    printf(">>> Received Data(%d)!\r\n", ret);
#endif //_DEBUG_INFO
#endif
    //  创建值
    jbyteArray a = (env)->NewByteArray(ret);
    //  设置值
    (env)->SetByteArrayRegion(a, 0, ret, reinterpret_cast<const jbyte *>(data));
    //  返回
    return a;
}

/*
 * Class:     com_tanso_rfidlib_port_usb_NativeUsb
 * Method:    IoCtrl
 * Signature: (I[B)[B
 */
JNIEXPORT jbyteArray
JNICALL Java_com_tanso_rfidlib_port_usb_NativeUsb_IoCtrl(JNIEnv *env, jobject thiz, jint param, jbyteArray data) {
    jbyte *pd;
    jboolean isCopy = 0;

    if (!hid_fd) {
        printf("ERROR : (IoCtrl) hid_fd is (null)!\r\n");
        return nullptr;
    }

    //  获取数据
    pd = (env)->GetByteArrayElements(data, &isCopy);
    //  锁定
    pthread_mutex_lock(&mt);
    //  控制
    int ret = ioctl(hid_fd, param, pd);
    //  解锁
    pthread_mutex_unlock(&mt);
    //  释放
    (env)->ReleaseByteArrayElements(data, pd, 0);
    //  创建
    jbyteArray ba = (env)->NewByteArray(1);

    return ba;
}

#ifdef __cplusplus
}
#endif

